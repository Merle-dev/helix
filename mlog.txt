Lsp(LspCompletionItem { item: CompletionItem { label: "iter().rfind(â€¦)(as DoubleEndedIterator)", label_details: None, kind: Some(Method), detail: Some("fn(&mut self, P) -> Option<<Self as Iterator>::Item>"), documentation: Some(MarkupContent(MarkupContent { kind: Markdown, value: "Searches for an element of an iterator from the back that satisfies a predicate.\n\n`rfind()` takes a closure that returns `true` or `false`. It applies\nthis closure to each element of the iterator, starting at the end, and if any\nof them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n`false`, it returns [`None`].\n\n`rfind()` is short-circuiting; in other words, it will stop processing\nas soon as the closure returns `true`.\n\nBecause `rfind()` takes a reference, and many iterators iterate over\nreferences, this leads to a possibly confusing situation where the\nargument is a double reference. You can see this effect in the\nexamples below, with `&&x`.\n\n[`Some(element)`]: Some\n\n# Examples\n\nBasic usage:\n\n```rust\nlet a = [1, 2, 3];\n\nassert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n\nassert_eq!(a.iter().rfind(|&&x| x == 5), None);\n```\n\nStopping at the first `true`:\n\n```rust\nlet a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\nassert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n\n// we can still use `iter`, as there are more elements.\nassert_eq!(iter.next_back(), Some(&1));\n```" })), deprecated: None, preselect: None, sort_text: Some("8000000b"), filter_text: Some("rfind"), insert_text: None, insert_text_format: Some(Snippet), insert_text_mode: None, text_edit: Some(InsertAndReplace(InsertReplaceEdit { new_text: "iter().rfind(${1:predicate})$0", insert: Range { start: Position { line: 54, character: 35 }, end: Position { line: 54, character: 35 } }, replace: Range { start: Position { line: 54, character: 35 }, end: Position { line: 54, character: 35 } } })), additional_text_edits: None, command: None, commit_characters: None, data: None, tags: None }, provider: LanguageServerId(1v1), resolved: true, provider_priority: 0 })
